pragma solidity ^0.8.0;

// Importing Provable is not required in this example

contract BusManagementSystem {
    address public owner;

    struct BusSchedule {
        string busId;
        string startDestination;
        string endDestination;
        uint startTime;
        uint endTime;
        uint availableSeats;
        uint ticketPrice;
        bool isActive;
        bool securityEnabled;
        mapping(address => bool) booked;
        mapping(uint => address) seatToPassenger;
    }

    mapping(uint => BusSchedule) public busSchedules;
    uint public scheduleCounter;

    event BusScheduleAdded(uint scheduleId, string busId, string startDestination, string endDestination, uint startTime, uint endTime, uint availableSeats, uint ticketPrice);
    event TicketIssued(address passenger, uint scheduleId, uint seatNumber);
    event DropLocationChanged(uint scheduleId, string newDropLocation);
    event StatusUpdated(uint scheduleId, bool isActive);
    event FinalDestinationChanged(uint scheduleId, string newDestination);
    event SecurityEnabled(uint scheduleId);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can perform this action.");
        _;
    }

    constructor() {
        owner = msg.sender;
        scheduleCounter = 0;
    }

    function addBusSchedule(string memory busId, string memory startDestination, string memory endDestination, uint startTime, uint endTime, uint availableSeats, uint ticketPrice) public onlyOwner {
        BusSchedule storage newSchedule = busSchedules[scheduleCounter];
        newSchedule.busId = busId;
        newSchedule.startDestination = startDestination;
        newSchedule.endDestination = endDestination;
        newSchedule.startTime = startTime;
        newSchedule.endTime = endTime;
        newSchedule.availableSeats = availableSeats;
        newSchedule.ticketPrice = ticketPrice;
        newSchedule.isActive = true;
        newSchedule.securityEnabled = false;

        emit BusScheduleAdded(scheduleCounter, busId, startDestination, endDestination, startTime, endTime, availableSeats, ticketPrice);

        scheduleCounter++;
    }

    function issueTicket(uint scheduleId, uint seatNumber) public {
        require(scheduleId < scheduleCounter, "Invalid schedule ID");
        BusSchedule storage schedule = busSchedules[scheduleId];
        require(schedule.availableSeats > 0, "No available seats for this schedule");
        require(!schedule.booked[msg.sender], "You have already booked a seat");
        require(seatNumber < schedule.availableSeats, "Invalid seat number");

        schedule.availableSeats--;
        schedule.booked[msg.sender] = true;
        schedule.seatToPassenger[seatNumber] = msg.sender;

        emit TicketIssued(msg.sender, scheduleId, seatNumber);
    }

    function changeDropLocation(uint scheduleId, string memory newDropLocation) public onlyOwner {
        require(scheduleId < scheduleCounter, "Invalid schedule ID");
        busSchedules[scheduleId].endDestination = newDropLocation;
        emit DropLocationChanged(scheduleId, newDropLocation);
    }

    function updateStatus(uint scheduleId, bool newStatus) public onlyOwner {
        require(scheduleId < scheduleCounter, "Invalid schedule ID");
        busSchedules[scheduleId].isActive = newStatus;
        emit StatusUpdated(scheduleId, newStatus);
    }

    function changeFinalDestination(uint scheduleId, string memory newDestination) public onlyOwner {
        require(scheduleId < scheduleCounter, "Invalid schedule ID");
        busSchedules[scheduleId].endDestination = newDestination;
        emit FinalDestinationChanged(scheduleId, newDestination);
    }

    function enableSecurity(uint scheduleId) public onlyOwner {
        require(scheduleId < scheduleCounter, "Invalid schedule ID");
        busSchedules[scheduleId].securityEnabled = true;
        emit SecurityEnabled(scheduleId);
    }

    function disableSecurity(uint scheduleId) public onlyOwner {
        require(scheduleId < scheduleCounter, "Invalid schedule ID");
        busSchedules[scheduleId].securityEnabled = false;
        emit StatusUpdated(scheduleId, false);
    }

    function getScheduleDetails(uint scheduleId) public view returns (string memory, string memory, string memory, uint, uint, uint, uint, bool, bool) {
        require(scheduleId < scheduleCounter, "Invalid schedule ID");
        BusSchedule storage schedule = busSchedules[scheduleId];
        return (schedule.busId, schedule.startDestination, schedule.endDestination, schedule.startTime, schedule.endTime, schedule.availableSeats, schedule.ticketPrice, schedule.isActive, schedule.securityEnabled);
    }

    function getPassengerSeat(uint scheduleId, uint seatNumber) public view returns (address) {
        require(scheduleId < scheduleCounter, "Invalid schedule ID");
        return busSchedules[scheduleId].seatToPassenger[seatNumber];
    }
}

